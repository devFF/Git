## Основные команды
Git может отслеживать файлы проекта только в том случае, когда они помещены под контроль версий. Для этого нужно зайти в директорию проекта и выполнить команду инициализации git init.
```bash
# Создаем новый проект
mkdir hexlet-git

# Переходим в созданную директорию
cd hexlet-git

# Выполняем инициализацию
git init
```

Команда ```git init``` создает репозиторий — директорию *.git*, которая содержит все необходимые для работы Git-файлы.

С помощью команды ```git status``` можно посмотреть статус репозитория.

## Добавление новых файлов
Добавим два файла:
```bash
# Создаем файл README.md со строкой текста
echo 'Hello, Hexlet!' > README.md
echo 'Haskell Curry' > PEOPLE.md
```
Посмотрим статус:
```bash
git status

# Часть вывода убрана
Untracked files:
  (use "git add <file>..." to include in what will be committed)
    PEOPLE.md
    README.md
```
Git увидел, что в проекте появились новые файлы, о которых ему ничего не известно. Они помечаются как неотслеживаемые файлы (untracked files). Git не следит за изменениями в таких файлах, потому что они не добавлены в репозиторий.

Добавление в репозиторий происходит в два шага. Первым шагом выполняем команду подготовки файлов ```git add <путь до файла>```:
```bash
# Для каждого нового или измененного файла
git add README.md
```
Файл README.md теперь находится в состоянии «подготовлен к коммиту» — другими словами, файл попал в индекс.

Следующий шаг — это коммит. Под этим термином понимается окончательное добавление в репозиторий, когда Git запоминает файл навсегда и следит за всеми последующими изменениями.
```bash
git commit -m 'add README.md'
```

## Создадим (переместим наш локальный репозиторий) в github

```bash
# git remote add origin git@github.com:Логин/Название репозитория.git
git remote add origin git@github.com:devFF/Git.git
git branch -M main
git push -u origin main
```
Команда ```git remote``` служит для управления списком удалённых репозиториев. Она позволяет сохранять длинные URL репозиториев в виде понятных коротких строк, например "origin", так что вам не придётся забивать голову всякой ерундой и набирать её каждый раз для связи с сервером. Вы можете использовать несколько удалённых репозиториев для работы и ```git remote``` поможет добавлять, изменять и удалять их.

## Команды Clone, Fetch, Pull & Push
Командой ```git clone``` можно скопировать скачать репозиторий себе на компьютер.
Команда ```git push``` отправляет изменения во вновь созданный репозиторий
Команда ```git pull``` работает как комбинация команд ```git fetch``` и ```git merge```, т.е. Git вначале забирает изменения из указанного удалённого репозитория, а затем пытается слить их с текущей веткой.
Аналог pull: ```git pull --rebase```.
Команда ```git fetch``` связывается с удалённым репозиторием и забирает из него все изменения, которых у вас пока нет и сохраняет их локально.

## Как удалить файл/папку из git
```bash
# To delete a file:
$ git rm my-file.txt

# To delete a folder, add the '-r' option:
$ git rm -r my-folder
```

## Анализ сделанных изменений
Чтобы посмотреть какие строки и как изменились в git:
```bash
git diff
```
По умолчанию команда ```git diff``` показывает изменения только для тех модифицированных файлов, которые еще не были добавлены в индекс. Подразумевается, что добавленные в индекс файлы смотреть не нужно, ведь мы их уже подготовили к коммиту. Но лучше еще раз увидеть эти изменения и все проверить. Для этого нужно запустить команду ```git diff``` с флагом ```--staged```:
```bash
# Выведет все изменения, сделанные в рабочей директории
# которые были добавлены в индекс
git diff --staged
```

## Анализ истории изменений
Самая простая аналитика выполняется командой ```git log```. Она показывает список всех выполненных коммитов, отсортированных по дате добавления. Сверху мы видим самые последние коммиты:
```bash
git log

# Ниже неполный вывод истории проекта

commit 5120bea3e5528c29f8d1da43731cbe895892eb6d
Author: tirion <tirion@got.com>
Date:   Thu Sep 17 18:04:19 2020 -0400

    add new content

commit e6f625cf8433c8b1f1aaed58cd2b437ec8a60f27
Author: tirion <tirion@got.com>
Date:   Thu Sep 17 16:14:09 2020 -0400
```
У команды ```git log``` есть полезный флаг ```-p```, который сразу выводит диф для каждого коммита:
```bash
git log -p
# Тут все коммиты с полным дифом
# Промотать вперед — кнопка f, промотать назад — b
# Выйти из режима просмотра — q
```

### Команда git show
У каждого коммита есть уникальный набор символов — идентификатор (еще говорят «хеш»). С помощью хеша можно посмотреть все изменения, сделанные в рамках одного коммита:
```bash
git show 5120bea3e5528c29f8d1da43731cbe895892eb6d
# Тут выводится диф между этим коммитом и предыдущим
```
Хеши коммитов в Git очень длинные, и ими бывает неудобно пользоваться. Поэтому разработчики Git добавили возможность указывать только часть хеша. Достаточно взять первые семь символов и подставить их в ту команду, которая работает с коммитами

### Команда git blame
А что если мы не знаем коммита, но нам интересно, кто последним менял конкретную строчку в файле? Для этого подойдет команда git blame <путь до файла>. Эта команда выводит файл и рядом с каждой строчкой показывает того, кто ее менял и в каком коммите:
```bash
git blame INFO.md

e6f625cf (tirion 2020-09-17 16:14:09 -0400 1) git is awesome!
5120bea3 (tirion 2020-09-17 18:04:19 -0400 2) new line
```

### Команда git grep
Команда ```git grep``` ищет совпадение с указанной строкой во всех файлах проекта. Это очень удобная команда для быстрого анализа из терминала. Она удобнее обычного ```grep```, потому что знает про игнорирование и не смотрит в директорию *.git*, а еще умеет искать по истории:
```bash
git grep line

INFO.md:new line

# Флаг `i` позволяет искать без учета регистра
git grep -i hexlet

README.md:Hello, Hexlet! How are you?

# Поиск в конкретном коммите
git grep Hexlet 5120bea

# Поиск по всей истории
# Возвращаем список хешей коммитов `rev-list`
git grep Hexlet $(git rev-list --all)
```


